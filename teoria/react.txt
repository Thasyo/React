Seção 02 - FUNDAMENTOS DO REACT

    - CRIANDO COMPONENTES

        -> Na maioria dos projetos, os componentes ficam em uma pasta chamada de "components", que devemos criar;
        -> Geralmente, são criados com a Camel Case: "FirstComponent.js";
        -> Neste arquivo, criamos uma função, que contém o código deste componente (lógica e o template);
        -> Também, devemos exportar essa função, a fim de reutilizá-la;
    
    - IMPORTANDO COMPONENTES

        -> A importação é a maneira que temos de reutilizar o componente;
        -> Utilizamos a sintaxe: import <NOME_COMPONENTE> from './componentes/<NOME_COMPONENTE>';
        -> Para colocar o componente importado em outro componente, precisamos colocá-lo em forma de tag: <FirstComponent/>;
        -> E então finalizamos o ciclo de importação;

    - JSX

        -> JSX é o HTML do React;
        -> Onde vamos declarar as tags de HTML que serão exibidas no navegador;
        -> Ficam no Return do componente;
        -> Temos algumas diferenças do HTML, por exemplo: class será "className";
        -> Isso se dá pelas instruções semelhantes de JS e HTML, pois o JSX é JavaScript, então algumas terão nomes diferentes;
        -> O JSX pode ter apenas UM elemento pai;

    - COMENTÁRIOS

        -> Os comentários, são colocados de duas maneiras:
        -> 1: Na parte da função, onde é executada a lógica, a sintaxe é: //algum comentário
        -> 2: No JSX: {/*algum comentário*/};
        -> Os comentários não aparecem no console do projeto;
    
    - TEMPLATE EXPRESSIONS

        -> É o recurso que nos permite executar JS no JSX e também interpolar variáveis;
        -> Isso será muito útil ao longo dos seus projetos em React;
        -> A sintaxe é: {algumCódigoEmJS};
        -> Tudo que está entre chaves é processado em JavaScript e nos retorna um resultado;


    - HIERARQUIA DE COMPONENTES

        -> Os componentes que criamos, podem ser reutilizados em vários componentes;
        -> E ainda componentes podem formar uma hierarquia, sendo importados uns dentro dos outros, como fizemos no "App.js";

    - EVENTO DE CLICK

        -> Os eventos para o front-end são essenciais;
        -> Em várias situações, vamos precisar do click, cmo ao enviar formulários;
        -> No react, os eventos já estão "prontos", podemos utilizar o 'onClick' para ativar uma função ao clicar em um elemento;
        -> Esta função é criada na própria função do componente;
        -> As funções, geralmente, tem o padrão "handleAlgumaCoisa";

    - FUNÇÕES NO EVENTO

        -> Quando as funções são simples, podemos realizar a lógica no próprio evento;
        -> Isso torna nosso código mais "complicado", por atrelar lógica com HTML;
        -> Mas em algumas situações, é aplicável;

    - FUNÇÕES DE RENDERIZAÇÃO

        -> Podemos criar funções que retornam JSX;
        -> Isso serve para criasr situações que dependam de outras condições;
        -> Ou seja, o JSX a ser renderizado pode variar por alguma variável, por exemplo;

Seção 03 - AVANÇANDO EM REACT

    - IMAGENS NO REACT

        -> As imagens públicas do nosso projeto podem ficar na pasta "public";
        -> De lá, elas podem ser chamadas pelas tags 'img' diretamente pelo '/nome.jpg';
        -> Pois a pasta 'public' fica linkada com o src das imagens;

    - IMAGENS EM UMA PASTA ESPECÍFICA

        -> A pasta 'public' pode ser utilizada para colocar imagens, como fizemos anteriormente;
        -> Mas um padrão bem utilizado para as imagens dos projetos, é colocar em uma pasta chamadas 'assets', em 'src';
        -> Ou seja, você vai encontrar projetos com as duas abordagens;
        -> Em 'assets', precisamos importar as imagens, e o 'src' é dinâmico com o nome da importação; 
    
    - O QUE SÃO HOOKS?

        -> Recursos do React que tem diversas funções;
        -> Como: guardar e alterar o estado de algum dado na nossa aplicação;
        -> Todos os hooks começam com o 'use', por exemplo: useState;
        -> Podemos criar nossos próprios hooks, isso é chamado de 'custom hook';
        -> Os hooks precisam ser importados;
        -> Geralmente, são úteis em todas as aplicações, utilizaremos diversos ao longo do curso;

    - USESTATE HOOK

        -> Utilizamos para gerenciar o estado de algum dado, variáveis não funcionam corretamente, o componente não re-renderiza;
        -> Para guardar o dado, definimos o nome da variável e para alterar, vamos utilizar o 'setNome', onde nome é o nome do nosso dado;

    - RENDERIZAÇÃO DE LISTA

        -> Uma outra ação bem comum, é renderizar listas de dados no template;
        -> Fazemops isso com os dados com tipo de array;
        -> UtilizandO O MÉTODO 'MAP' para nos auxiliar;
        -> Além dos dados, podemos inserir JSX em cada iteração;


    - A PROPRIEDADE 'KEY'

        -> Iterar listas sem a propriedade key, nos gera um "warning", podemos verificar isso no console;
        -> O react precisa de uma chave única em cada um dos itens listado;
        -> Isso serve para ajudá-lo na renderização do componente;
        -> Geralmente, teremos um array de objetos e podemos colocar 'key' como alguma chave única, como o id de algum dado;
        -> Em último caso, devemos utilizar o index do método map;

    - PREVIOUS STATE

        -> É um recurso que nos permite pegar o dado em seu valor original dentro de um set de dado;
        -> Isso é muito utilizado para modificar listas, pois temos o valor antigo e transformamos em um valor novo;
        -> O primeiro argumento de um set sempre será o "previous state";

    - RENDERIZAÇÃO CONDICIONAL

        -> É quando imprimimos uma parte do template baseado em uma condição;
        -> Isso é interessante em situações como: usuário autenticado/não autenticado;
    
    - IF E ELSE NO JSX

        -> Aqui, utilizamos o if ternário;
        -> sintaxe: <condição> ? <bloco 01> : <bloco 02>;

    - PROPS

        -> É outro recurso fundamental do React;
        -> Nos permite passar valores de um componente pai para um componente filho;
        -> Isso será muito útil quando forem carregados via bancos de dados, por exemplo;
        -> As Props vem um objeto no argumentp da função do componente;

    - DESESTRUTURANDO PROPS

        -> É super comum passar mais de uma props em um componente;
        -> Pra facilitar isso, o React nos permite desestruturar as propriedades que chegam, com o recurso de "destructuring";
        -> Se temos duas props: name e age;
        -> Podemos fazer da seguinte forma usando o desestructuring: "MyComponent({name, age})";
        -> Agora não precisamos sempre colocar: "props.AlgumaCoisa";

    - REUTILIZAÇÃO DE COMPONENTES

        -> Com props, a reutilização de componentes começa a fazer muito sentido;
        -> Se temos os dados de 1000 carros por exemplo, podemos reaproveitar o nosso CarDetails 1000 vezes;
        -> Isso torna nosso código mais padronizado, facilitando a manutenção;
    
    - RENDERIZAÇÃO COM LOOP

        -> Os arrays de dados podem ter muitos itens também;
        -> Então o correto é utilizar uma estrutura de loop (map) para a sua exibição;
        -> E com isso conseguimos conciliar os três conceitos: renderização de listas, reaproveitamento de componentes e props;
     
     - FRAGMENTOS

        -> Os React Fragments são interessantes para quando precisamos ter mais de um elemento pai em um componente;
        -> Criamos uma tag vazia: <> ... </>;
        -> E ela serve como elemento pai, não alterando a estrutura do html com uma div, por exemplo;
    
    - CHILDREN PROP
    
        -> É um recurso utilizado para quando um componente precisa ter JSX dentro dele;
        -> Porém, este JSX vem do componente PAI;
        -> Então, o componente age como um "container", abraçando estes elementos;
        -> É children é considerada uma prop do componente;

    - FUNÇÕES EM PROPS

        -> As funções podem ser passadas para as props normalmente;
        -> Basta criar a função no componente pai e enviar como prop para o componente;
        -> No componente filho, ela pode ser ativada por um evento, por exemplo;

    - ELEVAÇÃO DE ESTADO (STATE LIFT)

        -> É quando um valor é elevado do componente filho para o componente pai;
        -> Geralmente, temos um componente que usa o state e outro que o altera;
        -> Então precisamos passar a alteração para o componente pai, e este passa para o componente que usa o state;

SEÇÃO 04 - CSS NO REACT

    - CSS GLOBAL

        -> É utilizado para estilizar diversos elementos em comum ou fazer um reset no CSS;
        -> Utilizamos o arquivo "index.css" para isso;
        -> Ele está na pasta "src";

    - CSS DE COMPONENTE

        -> É utilizado para um componente em específico;
        -> Geralmente, é criado um arquivo com o mesmo nome do componente e este é importado no componente;
        -> Note que, esete método não é scoped, ou seja, o CSS pode vazar pra outros componentes se houver uma regra de colisão;
        -> O React já cria um exemplo desta técnica com o App.css/js;

    - CSS INLINE

        -> É igual o do CSS;
        -> Por meio do atributo style, conseguimos aplicar regras diretamente em um elemento;
        -> Devemos optar por outras maneiras de CSS, pois o inline pode dificultar a manutenção ou deixar o código imprevisível em algumas situações;

    - INLINE STYLE DINÂMICO

        -> O css dinâmico inline, aplica o estilo baseado m uma condicional;
        -> Vamos inserir no atributo um "if ternário";
        -> Dependendo da condição podemos mudar que regras de estilo um elemento recebe;

    - CLASSES DINÂMICAS NO CSS

        ->  Podemos aplicar lógica para mudar a classe de CSS de um elemento;
        -> Também utilizaremos o if ternário;
        -> Essa abordagem é maias interessante, pois as classes irão estar isoladas em um arquivo CSS;
        -> Também, com este método, resolvemos a quetsão da oragnização do código;

    - CSS MODULES

        -> É um recurso de CSS SCOPED;
        -> Ele vai ser exclusivo do componente em questão;
        -> O nome do arquivo é: <nome_componente>.modules.css;
        -> Precisamos importá-lo também no componente;
    

SEÇÃO 05 - FORMULÁRIOS EM REACT

    - FORMULÁRIOS E REACT
    
        -> Utilizamos a tag <Form> para formulários;
        -> As labs dos inputs contém o atributo "htmlFor", que deve ter o valor do name do input;
        -> Não utilizamos 'action', pois o processamento será feito de forma assíncrona;
    
    - LABEL ENVOLVENDO INPUT

        -> Em React, um padrão comum é a tag label envolvendo o input;
        -> Isso faz com que o atributo for se torne opcional;
        -> Simplificando nossa estrutura HTML, sem perder a semântica;

    - MANIPULANDO VALORES

        -> Para manipular os valores dos inputs, vamos utilizar o hook "useState";
        -> Podemos armazenar na variável e utilizar o set para alterar o valor;
        -> Vamos criar uma função para alterar o valor no evento "onChange";
        -> Deixando nosso código fácil de trabalhar nas próximas etapas: como no envio dos dados para BD e validação;

    - SIMPLIFICANDO A MANIPULAÇÃO DOS VALORES

        -> Quando temos vários inputs, podemos realizar a manipulação de forma mais simples;
        -> Basicamente, criamos uma função inline dentro do onChange de cada input, colocando o set<Nome_state>;
        -> Ela vai alterar o valor do state com o método set, da mesma forma que a função isolada;

    - ENVIO DO FORMULÁRIO

        -> Para enviar um form, vamos utilizar o evento "onSubmit";
        -> Ele chamará uma função, e nesta, devemos lembrar de parar a submissão com o "preventDefault";
        -> Nesta etapa, podemos realizar validações, envio de form para o servidor, reset de form e outras ações;
    
    - CONTROLLED INPUTS

        -> É um recurso que nos permite mais flexibilidade nos forms de React;
        -> Precisamos apenas igualar o valor ao state;
        -> Um uso muito comum: formulários de eedição, que os dados já vem do backend;
    
    - RESETANDO FORMULÁRIOS

        -> Com o controller inputs, limpar forms será mais fácil;
        -> Basta atribuir um valor de uma string vazia aos states e pronto;
        -> Isso será feito após o envio, em forms que o usuário orecisa preencher novamente;
    
    - INPUT DE TEXTAREA

        -> O TEXTAREA pode ser considerado um input de text normal;
        -> Utilizaremos o value para alterar o state incial;
        -> E o evento onChange, para modificar o valor do state;

    - INPUT DE SELECT

        -> O select será muito semelhante aos outros inputs;
        -> Quando temos a alteração de um valr o evento onChange pode captar isso;
        -> O value também pode atribuir qual "option" estará selecionada;
    
SEÇÃO 07 - REQUISIÇÕES HTTP

    - JSON SERVER

        -> É um pacote NPM;
        -> Ele simula uma API, e isso nos possibilita fazer requisições HTTP;
        -> Vamos aprender a integrar este recurso com o react;
        -> Podemos entender isso como uma etapa de preparação para APIs reais;
        -> Ou seja, atingir o mesmo resultado mas sem precisar de uma estrutura no back-end;

    - A IMPORTÂNCIA DO UseEFFECT

        -> O UseEffect faz com que determinada ação seja executada apenas uma vez;
        -> Isso é interessante pois os componentes estão sempre se re-renderizando, então precisamos ter ações únicas às vezes;
        -> O UseEffect ainda possui um array de dependências, que deve conter os dados que ativem a execução da função de forma automática;
        -> O UseEffect estará presente sempre nas requisições assíncronas;
    
    - RESGATANDO DADOS COM REACT

        -> Para trazer os dados, vamos ter que utilizar vários Recursos;
        -> primeiro: Ter um local para salvar (useState);
        -> Depois, renderizar a chamada a API apenas uma vez (UseEffect);
        -> Depois, um meio de fazer a requisição assíncrona (Fetch API);

    - ADICIONANDO DADOS

        -> Para adicionar um item, vamos precisar resgatar os dados do form, com o useState;
        -> Reunir eles em uma função após o submit e enviar um request de POST para a nossa API;
        -> O processo é parecido com o de resgate de dados, mas agora estamos enviando dados;

    - CARREGAMENTO DINÂMICO DE DADOS

        -> Se a requisição foi feita com sucesso, podemos adicionar o item a list após o request;
        -> Isso torna nossa aplicação mais performática;
        -> Utilizaremos o set do useState para isso;

    - CUSTOM HOOK PARA O FETCH

        -> É normal dividir funções que podem ser reaproveitadas em hooks;  
        -> Esta técnica é chamada de  custom hook, e vamos criar um para o resgate de dados;
        -> Os hooks geralmente ficam na pasta "hooks";
        -> Devemos utilizar o padrão useName;
        -> Basicamente criamos uma função e exportamos ela;
    
    - REFATORANDO POST

        -> Podemos utilizar o mesmo hook para incluir uma etapa de POST;
        -> Vamos criar um novo useEffect que mapeia uma outra mudança de estado;
        -> Após ela ocorrer executamos a adição do produto;
        -> OBS: nem sempre reutilizar um hook é a melhor estratégia;
        
    - ESTADO DE LOADING

        -> Quando fizermos requsiições para Apis é normal que haja um intervalo de loading entre a requisição e o recebimento da resposta;
        -> Podemos fazer isso no nosso hook também;
        -> Identificar quando começa e termina este estado;

    - LOADING NO POST

        -> Podemos bloquear ações indevidas em outras requests também, como no POST;
        -> Uma ação interessante é remover a ação de adicionar outro item enquanto o request ainda não realizou;

    - TRATAMENTO DE ERROS

        -> Podemos tratar os erros das requisições por meio de um "Try | Catch";
        -> Além de pega os dados do erro, podemos alterar um state para imprimir um elemento se algo der errado;
        -> Desta maneira, conseguimos prever vários cenários (dados resgatados, Carregamento e erro);

    
SEÇÃO 08 - REACT ROUTER

    - O QUE É REACT ROUTER?

        -> É um dos pacotes mais utilizados para criar uma estrutura de rotas em aplicações de React;
        -> Permite que nossas SPAs tenham múltiplas páginas;
        -> Precisamos instalar no nosso projeto;
        -> A configuração e utilização é simples;
        -> Também temos outras funções, como: Redirect, Nested Routes, Not Found Routes e outros;
    
    - CONFIGURANDO O REACT ROUTER

        -> Para configurar o React Router, vamos ter que importar três elementos de react-router-dom;
        -> BroswerRouter: Define onde a área do nosso app vai trocar qas páginas;
        -> Routes: Define as rotas;
        -> Route: Um elemento deste para cada rota, configurar com Path e componente da rota;

    